#!/bin/sh
# vim: et sw=2 ts=2 tw=0:

__copyright__="Cyrille Pontvieux <jrd@enialis.net>"
__license__="GPLv2+"
__version__="1.0"

cd $(dirname "$0")
# encusre /sbin and /usr/sbin are in the PATH (in case of a sudo)
PATH=/sbin:/usr/sbin:$PATH
export PATH
  
CFG_FILE=/etc/salixPackaging

CNONE="[0m"
CRED="[31m"; CLRED="[31;1m"
CGREEN="[32m"; CLGREEN="[32;1m"
CMAROON="[33m"; CYELLOW="[33;1m"
CBLUE="[34m"; CLBLUE="[34;1m"
CMAGENTA="[35m"; CLMAGENTA="[35;1m"
CCYAN="[36m"; CLCYAN="[36;1m"
CGREY="[37m"; CLGREY="[37;1m"
CWHITE="[38m"; CLWHITE="[38;1m"

usage() {
  needroot="$CLRED*$CNONE"
  cat <<EOF
Usage: salixPackaging [OPTIONS]
Help a packager to manage his/her packages for Salix.

Where OPTIONS are:
  -h, --help
    This usage
  -V, --version
    Show the version
  --check
    Sanity check of Host environment.
  --prepare $needroot
    Prepare the host to install LXC versions of Salix.
  --register
    Register your information as packager.
  --install=VERSION,ARCH $needroot
    Install a LXC version of Salix for the specified VERSION and ARCH. ARCH could be 'i486' or 'x86_64'.
  --list-installed
    List all LXC Salix version installed.
  --remove=VERSION,ARCH $needroot
    Remove a LXC Salix version.
  -c, --create
    Create a new package.
  -e, --edit=PACKAGE_NAME,VERSION,ARCH
    Edit a PACKAGE_NAME SLKBUILD file for Salix VERSION and ARCH. ARCH could also be 'noarch'.
  -l, --pkg-list
    Show all packages and their state.
  -p, --pkg-info=PACKAGE_NAME,VERSION
    Show some information about the PACKAGE_NAME for the Salix VERSION.
  -v, --verify=PACKAGE_NAME,VERSION
    Verify the latest stable version of the PACKAGE_NAME for the Salix VERSION.
  -a, --verify-all
    Verify the latest stable version on all packages. Will take some time.
  -b, --build=PACKAGE_NAME,VERSION,ARCH
    Schedule to build PACKAGE_NAME for Salix version VERSION and ARCH..
  -q, --queue
    Show the schedule queue.
  -r, --rsync
    Rsync the local repo to your remote one.
  -t, --ticket=PACKAGE_NAME,VERSION
    Create a ticket on Salix Tracker about PACKAGE_NAME and Salix VERSION for all built ARCH.
  -i, --interactive
    Will enter an interactive mode if used with -l, -p, -v, -q. Creating a package (-c), editing a package (-e), and creating a ticket (-t) are always interactive.

  $needroot: root privileges required.
EOF
}

show_version() {
  cat <<EOF
salixPackaging v.$__version__
Copyright $__copyright__
License $__license__
EOF
}

usage_ver_arch() {
  cat <<EOF
LXC should be filled in the form:
  version,arch
Where 'version' could be '14.0', '14.1' for example
And 'arch' could be 'i486' or 'x86_64'.
EOF
}

usage_pkg_ver() {
  cat <<EOF
Package should be filled in the form:
  package_name,version
Where 'version' could be '14.0', '14.1' for example.
EOF
}

usage_pkg_ver_arch() {
  cat <<EOF
Package should be filled in the form:
  package_name,version,arch
Where 'version' could be '14.0', '14.1' for example
And 'arch' could be 'i486', 'x86_64' or 'noarch'.
EOF
}

check_root() {
  if [ $(id -u) -ne 0 ]; then
    echo "You should run this action with root privileges." >&2
    exit 1
  fi
}

action_check() {
  ok="${CLGREEN}OK$CNONE"
  fail="${CLRED}Fail$CNONE"
  if lxc-checkconfig; then
    echo "LXC: $ok"
  else
    echo "LXC: $fail"
    return 1
  fi
  echo -n "Arch: "
  if [ $(uname -m) = x86_64 ]; then
    echo "$ok"
  else
    echo "$fail"
    echo "You're not running a 64bits OS, you will not be able to build x86_64 package." >&2
    echo "Please, run a Salix 64bits to make packages." >&2
    return 1
  fi
  echo -n "rc.local: "
  if grep -q lxcbr0 /etc/rc.d/rc.local; then
    echo "$ok"
  else
    echo "$fail"
    echo "rc.local seems not to contain the needed preparation for LXC Bridge." >&2
    echo "Please, launch the prepare action." >&2
    return 1
  fi
  echo -n "Bridge: "
  if ifconfig|grep -q 'lxcbr0:'; then
    echo "$ok"
  else
    echo "$fail"
    echo "lxcbr0 bridge interface seems not to be configured." >&2
    echo "Please, run /etc/rc.d/rc.local to install it." >&2
    return 1
  fi
  return 0
}

action_prepare() {
  check_root
  cat <<'EOF' >> /etc/rc.d/rc.local
# salixPackaging
brctl addbr lxcbr0
brctl setfd lxcbr0 0
networkBase=192.168.100
ifconfig lxcbr0 $networkBase.1 netmask 255.255.255.0 promisc up
extIface=$(ifconfig|grep -B1 'inet '|sed -nr '/^[^:]+:/ { s/^([^:]+):.*/\1/; h }; $ {g;p}')
iptables -t nat -A POSTROUTING -s $networkBase.0/24 -o $extIface -j MASQUERADE
echo 1 > /proc/sys/net/ipv4/ip_forward
EOF
  cat <<'EOF' >> /etc/rc.d/rc.local_shutdown
# salixPackaging
ifconfig lxcbr0 down
brctl delbr lxcbr0
EOF
  brctl addbr lxcbr0
  brctl setfd lxcbr0 0
  networkBase=192.168.100
  ifconfig lxcbr0 $networkBase.1 netmask 255.255.255.0 promisc up
  extIface=$(ifconfig|grep -B1 'inet '|sed -nr '/^[^:]+:/ { s/^([^:]+):.*/\1/; h }; $ {g;p}')
  iptables -t nat -A POSTROUTING -s $networkBase.0/24 -o $extIface -j MASQUERADE
  echo 1 > /proc/sys/net/ipv4/ip_forward
  touch $CFG_FILE
  chmod a+rw $CFG_FILE
  echo "Bridge interface ${CLGREEN}lxcbr0$CNONE configured. Using IP ${CLGREEN}$networkBase.1$CNONE."
}

notnull() {
  [ -n "$1" ]
}
READ_VALUE=
# Prompt for a value, using an optional default value
# $1 = prompt
# $2 = default value
# $3 = command to check for validity, takes a value as argument. 'notnull' is accepted as special value
# The value is put in the global READ_VALUE variable
# exit with error on ctrl+c
read_info() {
  prompt="$1"
  def="$2"
  check="$3"
  [ -z "$check" ] && check=true
  value=
  [ -n "$def" ] && prompt="$prompt [$def]: " || prompt="$prompt: "
  valid=false
  trap 'echo;echo "Interrupted";break' 2 # will break on ctrl+c
  while ! $valid; do
    printf "$prompt"
    read -r value # hopes the -r is portable enough
    [ -n "$def" ] && [ -z "$value" ] && value="$def"
    $check "$value" && valid=true
  done
  trap 2 # restore normal behavior
  if $valid; then
    READ_VALUE=$value
    return 0
  else
    READ_VALUE=
    return 1
  fi
}
# Will ask for a choice between possibilities.
# case insensitive (A-Z only)
# $1 = prompt
# $2 = choices, separated by spaces in lowercase
# $3 = default value
# The chosen value is put in the global READ_VALUE variable
# exit with error on ctrl+c
read_choice() {
  prompt="$1"
  choices="$2"
  def="$3"
  value=
  prompt="$prompt ["
  first=true
  for c in $choices; do
    $first || prompt="${prompt}/"
    first=false
    [ "$c" = "$def" ] && c=$(echo "$c"|tr a-z A-Z)
    prompt="${prompt}${c}"
  done
  prompt="$prompt]? "
  valid=false
  trap 'echo;echo "Interrupted";break' 2 # will break on ctrl+c
  while ! $valid; do
    printf "$prompt"
    read -r value # hopes the -r is portable enough
    value=$(echo "$value"|tr A-Z a-z)
    [ -n "$def" ] && [ -z "$value" ] && value="$def"
    for c in $choices; do
      if [ "$value" = "$c" ]; then
        valid=true
        break
      fi
    done
  done
  trap 2 # restore normal behavior
  if $valid; then
    READ_VALUE=$value
    return 0
  else
    READ_VALUE=
    return 1
  fi
}

action_register() {
  cat <<EOF
Packager Information
====================

Please give some information about yourself and about your remote repository.
If you don't have a remote repository to hold your packages, please send an
email to the ML http://lists.sourceforge.net/lists/listinfo/salix-main in
order to have a space at people.salixos.org.
If you never already made some packages for Salix, take a look here:
http://docs.salixos.org/wiki/Packaging_rules

Hit Ctrl+C to abort.

EOF
  read_info 'Name' '' notnull || return 1
  name="$READ_VALUE"
  read_info 'Email' '' notnull || return 1
  email="$READ_VALUE"
  abbrev=$(for n in $(echo "$name"|tr '-' ' '); do echo -n "$n"|sed -r 's/^(.).*/\1/'|tr A-Z a-z; done)
  read_info 'Package abbreviation' "$abbrev" || return 1
  abbrev="$READ_VALUE"
  read_info 'Remote URL' "http://people.salixos.org/$USER" check_url || return 1
  url="$READ_VALUE"
  read_info 'SCP URI for Rsync' "simplynux.net:www" check_scp_uri || return 1
  scpuri="$READ_VALUE"
  read_info 'Schema location' '$pkgname/$pkgver-$arch' notnull || return 1
  schema="$READ_VALUE"
  cat <<EOF > $CFG_FILE
pkgr_name=$name
pkgr_email=$email
pkgr_abbrev=$abbrev
pkgr_url=$url
pkgr_scpuri=$scpuri
pkgr_schema=$schema
pkgr_user=$USER
pkgr_uid=$(id -u)
EOF
  return 0
}

check_url() {
  url="$1"
  if ! wget --no-check-certificate -O /dev/null -q "$url"; then
    echo "$url is not valid" >&2
    false
  fi
}

check_scp_uri() {
  scpuri="$1"
  tmp=$(mktemp -d)
  if sshfs -o uid=$(id -u) -o gid=$(id -g) "$scpuri" $tmp; then
    echo "Connection ok, disconnecting..."
    sleep 3
    fusermount -u $tmp
    sleep 1
    rmdir $tmp
    true
  else
    rmdir $tmp
    echo "$scpuri is not valid" >&2
    false
  fi
}

check_registered() {
  if [ ! -r $CFG_FILE ]; then
    echo "You should first register as a packager." >&2
    exit 1
  fi
}

action_install() {
  ver=$1
  arch=$2
  check_root
  check_registered
  echo "Creating LXC Salix $ver - $arch"
  # find next number for IP and Mac address
  n=$(lxc-ls -1|grep '^salixpkg-'|wc -l)
  # host start at 1, so next add +1
  NUMIP=$(($n + 1))
  NUMMAC=$(/bin/echo -e "obase=16\n$n + 1"|bc) # hexa
  conf=$(mktemp)
  sed -r "s/@NUMIP@/$NUMIP/; s/@NUMMAC@/$NUMMAC/;" lxc-default.conf > $conf
  name=salixpkg-$ver-$arch
  if lxc-create -n $name -f $conf -t $PWD/lxc-salix; then
    rm $conf
    . $CFG_FILE
    echo "pkg::$pkgr_uid:users:::/bin/bash"|/usr/sbin/newusers -R /var/lib/lxc/$name/rootfs
    /usr/sbin/usermod -R /var/lib/lxc/$name/rootfs -a -G lp,wheel,floppy,audio,video,cdrom,plugdev,power,netdev,scanner pkg
    if lxc-start -d -n $name; then
      echo "LXC started."
      return 0
    else
      echo "Cannot start the LXC." >&2
      return 1
    fi
  else
    rm $conf
    echo "Cannot create the LXC." >&2
    return 1
  fi
}

action_listinstalled() {
  lxc-ls -1|sort|sed -rn '/^salixpkg-/{s/^salixpkg-([^-]+)-(.*)/ - \1, \2/;p}'
  return $?
}

action_remove() {
  ver=$1
  arch=$2
  check_root
  echo "Removing LXC Salix $ver - $arch"
  lxc-destroy -n salixpkg-$ver-$arch
  return $?
}

action_create() {
  cat <<EOF
Package creation
================

EOF
  read_info 'Package name' '' notnull || return 1
  pkg_name="$READ_VALUE"
  read_info 'Home page' '' check_url || return 1
  pkg_url="$READ_VALUE"
  read_info 'Download URL page' '' check_url || return 1
  pkg_dl_url="$READ_VALUE"
  read_choice "Latest version check schema\n" 'sf_latest sf_folders sf_files github apache nginx googlecode launchpad custom md5sum' 'sf_latest' || return 1
  pkg_check_schema="$READ_VALUE"
  case $pkg_check_schema in
    sf_latest)
      pkg_check_pattern='grep -A1 "/files/latest/download"|sed -rn '\''/>Download /{s,.*Download .+-([^-]+)\.tar\.[bgx]z2? .*,\\1,;p}'\'
      ;;
    sf_folders)
      pkg_check_pattern='grep -B1 "Click to enter "|sed -rn '\''/href/{s,.*/([^/]+)/".*,\\1,;p}'\''|sort -rV'
      ;;
    sf_files)
      pkg_check_pattern='grep "Click to download "|sed -r '\''s,.*download .+-([^-]+)\.tar\.[bgx]z2?\".*,\\1,'\''|sort -rV'
      ;;
    github)
      pkg_check_pattern="md5sum|sed 's/  -//; s/^/MD5:/'"
      ;;
    apacheindex)
      pkg_check_pattern="md5sum|sed 's/  -//; s/^/MD5:/'"
      ;;
    nginxindex)
      pkg_check_pattern="md5sum|sed 's/  -//; s/^/MD5:/'"
      ;;
    googlecode)
      pkg_check_pattern="md5sum|sed 's/  -//; s/^/MD5:/'"
      ;;
    launchpad)
      pkg_check_pattern="md5sum|sed 's/  -//; s/^/MD5:/'"
      ;;
    custom)
      echo "A custom pattern is a filter on the HTML download page"
      echo "in order to find the latest stable version."
      echo "Example for a sourceforge project named 'mysoft':"
      echo "  grep 'FIXME'|sed -r 'FIXME'|grep -v 'alpha\|beta\|rc'|sort -r -V|head -n 1"
      read_info 'Custom pattern' '' notnull || return 1
      pkg_check_pattern="$READ_VALUE"
      ;;
    md5sum)
      pkg_check_pattern="md5sum|sed 's/  -//; s/^/MD5:/'"
  esac
  printf "Latest stable version found: "
  find_latest_version "$pkg_dl_url" "$pkg_check_pattern"
  printf "Latest version found: "
  find_latest_version "$pkg_dl_url" "$pkg_check_pattern" "" false
  read_choice "Is this ok? Continue" "y n" "y"
  if [ $READ_VALUE = y ]; then
    echo $pkg_name
    echo $pkg_url
    echo $pkg_dl_url
    echo $pkg_check_schema
    echo $pkg_check_pattern
    return 0
  else
    return 1
  fi
}

# Find the latest version
# Returns the version or "up to date" or "changed"
# $1 = URL to check
# $2 = pattern for the URL
# $3 = referenced md5sum
# $4 = from stable versions only (true, by default) or from all versions (false)
find_latest_version() {
  url="$1"
  pat="$2"
  md5ref="$3"
  stable="$4"
  [ -z "$stable" ] && stable=true
  filter=$(mktemp) # better than using eval I think.
  echo '#!/bin/sh' > $filter
  printf "$pat" >> $filter
  $stable && printf "|grep -vi 'alpha\\|beta\\|m[0-9]\\|rc'" >> $filter
  chmod +x $filter
  ver=$(wget --no-check-certificate -q -O - "$url"|$filter|head -n1)
  rm $filter
  if echo "$ver"|grep -q '^MD5:'; then
    md5=$(echo "$ver"|sed 's/MD5://')
    if [ "$md5" = "$md5ref" ]; then
      echo "up to date"
    else
      echo "changed"
    fi
  else
    echo "$ver"
  fi
}

action_edit() {
  pkgname=$1
  ver=$2
  arch=$3
  echo FIXME
  echo edit, pkgname=$pkgname, ver=$ver, arch=$arch
  return 0
}

action_pkglist() {
  echo FIXME
  echo pkglist
  echo INTERACTIVE=$INTERACTIVE
  return 0
}

action_pkginfo() {
  pkgname=$1
  ver=$2
  echo FIXME
  echo pkginfo, pkgname=$pkgname, ver=$ver
  echo INTERACTIVE=$INTERACTIVE
  return 0
}

action_verify() {
  pkgname=$1
  ver=$2
  echo FIXME
  echo verify, pkgname=$pkgname, ver=$ver
  echo INTERACTIVE=$INTERACTIVE
  return 0
}

action_verifyall() {
  echo FIXME
  echo verifyall
  echo INTERACTIVE=$INTERACTIVE
  return 0
}

action_build() {
  pkgname=$1
  ver=$2
  arch=$3
  echo FIXME
  echo build, pkgname=$pkgname, ver=$ver, arch=$arch
  return 0
}

action_queue() {
  echo FIXME
  echo queue
  echo INTERACTIVE=$INTERACTIVE
  return 0
}

action_rsync() {
  echo FIXME
  echo rsync
  return 0
}

action_ticket() {
  pkgname=$1
  ver=$2
  echo FIXME
  echo ticket, pkgname=$pkgname, ver=$ver
  return 0
}

opts=$(getopt -o 'hVce:lp:v:ab:qrt:i' -l 'help,version,check,prepare,install:,list-installed,remove:,register,create,edit:,pkg-list,pkg-info:,verify:,verify-all,build:,queue,rsync,ticket:,interactive' -- "$@")
ret=$?
if [ $ret -eq 1 ]; then
  usage
  exit $ret
else
  eval set -- $opts
  INTERACTIVE=0
  ACTION=''
  PARAM1=''
  PARAM2=''
  PARAM3=''
  while [ -n "$1" -a "$1" != "--" ]; do
    case "$1" in
      -h|--help)
        shift
        usage
        exit 0
        ;;
      -V|--version)
        shift
        show_version
        exit 0
        ;;
      --check)
        shift
        ACTION=check
        ;;
      --prepare)
        shift
        ACTION=prepare
        ;;
      --register)
        shift
        ACTION=register
        ;;
      --install)
        shift
        ACTION=install
        verarch=$1
        shift
        echo "$verarch"|grep -vq '^[^,]\+,[^,]\+$' && usage_ver_arch && exit 1
        PARAM1=$(echo $verarch|cut -d, -f1)
        PARAM2=$(echo $verarch|cut -d, -f2)
        ;;
      --list-installed)
        shift
        ACTION=listinstalled
        ;;
      --remove)
        shift
        ACTION=remove
        verarch=$1
        shift
        echo "$verarch"|grep -vq '^[^,]\+,[^,]\+$' && usage_ver_arch && exit 1
        PARAM1=$(echo $verarch|cut -d, -f1)
        PARAM2=$(echo $verarch|cut -d, -f2)
        ;;
      -c|--create)
        shift
        ACTION=create
        INTERACTIVE=1
        ;;
      -e|--edit)
        shift
        ACTION=edit
        INTERACTIVE=1
        fullpkg=$1
        shift
        echo "$fullpkg"|grep -vq '^[^,]\+,[^,]\+,[^,]\+$' && usage_pkg_ver_arch && exit 1
        PARAM1=$(echo $fullpkg|cut -d, -f1)
        PARAM2=$(echo $fullpkg|cut -d, -f2)
        PARAM3=$(echo $fullpkg|cut -d, -f3)
        ;;
      -l|--pkg-list)
        shift
        ACTION=pkglist
        ;;
      -p|--pkg-info)
        shift
        ACTION=pkginfo
        fullpkg=$1
        shift
        echo "$fullpkg"|grep -vq '^[^,]\+,[^,]\+$' && usage_pkg_ver && exit 1
        PARAM1=$(echo $fullpkg|cut -d, -f1)
        PARAM2=$(echo $fullpkg|cut -d, -f2)
        ;;
      -v|--verify)
        shift
        ACTION=verify
        fullpkg=$1
        shift
        echo "$fullpkg"|grep -vq '^[^,]\+,[^,]\+$' && usage_pkg_ver && exit 1
        PARAM1=$(echo $fullpkg|cut -d, -f1)
        PARAM2=$(echo $fullpkg|cut -d, -f2)
        ;;
      -a|--verify-all)
        shift
        ACTION=verifyall
        ;;
      -b|--build)
        shift
        ACTION=build
        fullpkg=$1
        shift
        echo "$fullpkg"|grep -vq '^[^,]\+,[^,]\+,[^,]\+$' && usage_pkg_ver_arch && exit 1
        PARAM1=$(echo $fullpkg|cut -d, -f1)
        PARAM2=$(echo $fullpkg|cut -d, -f2)
        PARAM3=$(echo $fullpkg|cut -d, -f3)
        ;;
      -q|--queue)
        shift
        ACTION=queue
        ;;
      -r|--rsync)
        shift
        ACTION=rsync
        ;;
      -t|--ticket)
        shift
        ACTION=ticket
        INTERACTIVE=1
        fullpkg=$1
        shift
        echo "$fullpkg"|grep -vq '^[^,]\+,[^,]\+$' && usage_pkg_ver && exit 1
        PARAM1=$(echo $fullpkg|cut -d, -f1)
        PARAM2=$(echo $fullpkg|cut -d, -f2)
        ;;
      -i|--interactive)
        shift
        INTERACTIVE=1
        ;;
      *)
        echo "Unknown option $1" >&2
        exit 1
    esac
  done
  if [ -z "$ACTION" ]; then
    usage
    exit 1
  else
    action_$ACTION $PARAM1 $PARAM2 $PARAM3
  fi
fi
