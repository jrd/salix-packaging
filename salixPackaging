#!/usr/bin/env python
# coding: utf-8
# vim: et sw=2 sts=2 ts=2 tw=0:
"""
"""
from __future__ import division, absolute_import, print_function, unicode_literals

__app__ = 'SalixPacking'
__copyright__ = 'Copyright 2014, Cyrille Pontvieux'
__author__ = 'Cyrille Pontvieux <jrd@salixos.org>'
__license__ = 'GPLv2+'
__version__ = '1.1'

import os
import sys
import argparse
import subprocess
from signal import signal, SIGPIPE, SIG_DFL
import tempfile
import time
import shutil
from glob import glob
import stat
import urllib
import urllib2
import json
import re
import hashlib
try:
  os.sync
except AttributeError:
  import ctypes
  def sync():
    try:
      libc = ctypes.CDLL('libc.so.6')
      libc.sync()
    except:
      pass
  os.sync = sync

class Colors(object):
  none="[0m"
  bold="[;1m"
  red="[31m"
  lred="[31;1m"
  green="[32m"
  lgreen="[32;1m"
  maroon="[33m"
  yellow="[33;1m"
  blue="[34m"
  lblue="[34;1m"
  magenta="[35m"
  lmagenta="[35;1m"
  cyan="[36m"
  lcyan="[36;1m"
  grey="[37m"
  lgrey="[37;1m"
  white="[38m"
  lwhite="[38;1m"
  @staticmethod
  def wrap(color, msg):
    return getattr(Colors, color) + msg + Colors.none

def check_root(self):
  if os.getuid() != 0:
    print('Root privileges are required', file = sys.stderr)
    sys.exit(1)

def execute(cmd):
  return subprocess.call(cmd, preexec_fn = lambda: signal(SIGPIPE, SIG_DFL), shell = True)

def get_exec(cmd):
  try:
    return subprocess.check_output(cmd, stderr = subprocess.STDOUT, preexec_fn = lambda: signal(SIGPIPE, SIG_DFL), shell = True)
  except subprocess.CalledProcessError:
    return None

def read_info(prompt, default = None, check = lambda v: True):
  """
  Prompt for a value, using an optional default value.
  check is a function taking a value to check as argument.
  Returns the read value.
  """
  value = ''
  if default:
    fullprompt = "{p} [{d}]: ".format(p = prompt, d = default)
  else:
    fullprompt = "{p}: ".format(p = prompt)
  valid = False
  while not valid:
    try:
      value = raw_input(fullprompt)
    except KeyboardInterrupt as e:
      print()
      raise ActionInterruptedException('Ctrl+C triggered')
    if default and not value:
      value = default
    valid = check(value)
  return value

def read_choice(prompt, choices = [], default = None, ci = True):
  """
  Will ask for a choice between possibilities.
  """
  fullprompt = prompt + ' ['
  first = True
  for c in choices:
    if first:
      first = False
    else:
      fullprompt += ','
    if default and c == default:
      fullprompt += Colors.wrap('bold', c)
    else:
      fullprompt += c
  fullprompt += ']? '
  valid = False
  while not valid:
    try:
      value = raw_input(fullprompt)
    except KeyboardInterrupt as e:
      print()
      raise ActionInterruptedException('Ctrl+C triggered')
    if default and not value:
      value = default
    valid = (ci and value.lower() in map(unicode.lower, choices)) or value in choices
  return value

def wget(url, filename = None, func = None, func_data = {}, quiet = False):
  """
  Download a remote resource specified by url.
  If filename is specified, the resource is stored in it.
  If func is specified, each line (with any \n kept) is passed to the 'func' function.
  quiet = True suppress any output.
  """
  req = urllib2.urlopen(url)
  if not filename and not func:
    print('wget: you should specify either filename or func', file = sys.stderr)
    sys.exit(127)
  if filename:
    f = open(filename, 'w')
    filter_func = None # ensure not both could be used
  if not quiet:
    meta = req.info()
    meta_func = meta.getheaders if hasattr(meta, 'getheaders') else meta.get_all
    meta_length = meta_func('Content-Length')
    file_size = None
    if meta_length:
      file_size = int(meta_length[0])
    print('Downloading: {url} ({size} bytes)'.format(url = url, size = file_size))
    file_size_dl = 0
  if filename:
    block_sz = 8192
  contenttype = req.headers.get('Content-Type', '').lower()
  if contenttype and 'charset=' in contenttype:
    encoding = contenttype.split('charset=', 2)[1]
  else:
    encoding = None
  if not encoding:
    encoding = 'utf-8'
  while True:
    if filename:
      buf = req.read(block_sz).decode(encoding)
      if not buf:
        break
      f.write(buf)
    elif func:
      line = req.readline().decode(encoding)
      if not line:
        break
      buf = len(line)
      func(line, **func_data)
    if not quiet:
      file_size_dl += len(buf)
      status = '{0:20,d}'.format(file_size_dl)
      if file_size:
        status += '   [{0:6.2f}%]'.format(file_size_dl * 100 / file_size)
      status += chr(13)
      print(status, end='')
  if not quiet:
    print()
  req.close()
  if filename:
    f.close()

def copytree(src, dst, symlinks = False, ignore = None):
  if not os.path.exists(dst):
    os.makedirs(dst)
    shutil.copystat(src, dst)
  lst = os.listdir(src)
  if ignore:
    excl = ignore(src, lst)
    lst = [x for x in lst if x not in excl]
  for item in lst:
    s = os.path.join(src, item)
    d = os.path.join(dst, item)
    if symlinks and os.path.islink(s):
      if os.path.lexists(d):
        os.remove(d)
      os.symlink(os.readlink(s), d)
      try:
        st = os.lstat(s)
        mode = stat.S_IMODE(st.st_mode)
        os.lchmod(d, mode)
      except:
        pass # lchmod not available
    elif os.path.isdir(s):
      copytree(s, d, symlinks, ignore)
    else:
      shutil.copy2(s, d)

def sort_software_versions(versions = [], reverse = True):
  if not versions:
    return []
  def split_version(version):
    def toint(x):
      try:
        return int(x)
      except:
        return x
    version = map(toint, re.sub(r'([a-z])([0-9])', r'\1.\2', re.sub(r'([0-9])([a-z])', r'\1.\2', version.lower().replace('-', '.'))).split('.'))
  def compare_version_list(l1, l2):
    def compare_version(v1, v2):
      if isinstance(v1, int):
        if isinstance(v2, int):
          return v1 - v2
        else:
          return 1
      else:
        if isinstance(v2, int):
          return -1
        else:
          return cmp(v1, v2)
    if not l1:
      l1 = []
    if not l2:
      l2 = []
    n1 = len(l1)
    n2 = len(l2)
    if n1 < n2:
      l1.extend([0]*(n2 - n1))
    if n2 < n1:
      l2.extend([0]*(n1 - n2))
    ret = 0
    i = 0
    n = max(n1, n2)
    while not ret and i < n:
      ret = compare_version(l1[i], l2[i])
      i += 1
    return ret
  return sorted(versions, cmp = compare_version_list, key = split_version, reverse = reverse)

def cat(filename):
  ret = None
  with open(filename, 'r') as f:
    ret = f.read().strip()
  return ret

def writefile(filename, s = None):
  with open(filename, 'w') as f:
    if s != None:
      f.write(s)

def touchfile(filename):
  open(filename, 'a').close()

def md5sum(content):
  return hashlib.md5(content).hexdigest()

def sha1(content):
  return hashlib.sha1(content).hexdigest()

#################################################

class ActionInterruptedException(Exception):
  pass

class SalixPackaging(object):
  """
  Handle the packaging of Salix packages
  """
  ok = Colors.wrap('lgreen', 'OK')
  fail = Colors.wrap('lred', 'Fail')
  cfg_file = '/etc/salixPackaging'
  localrepo_url = 'https://github.com/jrd/localrepo/raw/master/localrepo'
  network_base = '192.168.100'
  
  def __init__(self):
    self.args = {'interactive' : False}
  def is_interactive(self):
    return self.args['interactive']
  def check_notnull(self, value):
    return bool(value)
  def check_url(self, url):
    if url == 'SKIP':
      print('Skipping')
      return True
    if not url:
      return False
    try:
      urllib2.urlopen(url).close()
      return True
    except (ValueError, urllib2.URLError):
      print('{url} is not valid'.format(url = url), file = sys.stderr)
      return False
  def check_scp_uri(self, scpuri):
    if not scpuri:
      return False
    tmp = tempfile.mkdtemp()
    if execute('sshfs -o uid=$(id -u) -o gid=$(id -g) "{scpuri}" {tmp}'.format(scpuri = scpuri, tmp = tmp)) == 0:
      print('Connection ok, disconnecting...')
      time.sleep(3)
      execute('fusermount -u {tmp}'.format(tmp = tmp))
      time.sleep(1)
      os.rmdir(tmp)
      return True
    else:
      print('{scpuri} is not valid'.format(scpuri = scpuri), file = sys.stderr)
      os.rmdir(tmp)
      return False
  def check_arch(self, arch):
    if arch not in ('i486', 'x86_64'):
      print("ARCH should be 'i486' or 'x86_64'", file = sys.stderr)
      sys.exit(1)
  def getarg(self, action, pos):
    if action in self.args and self.args[action] and pos >= 1 and pos <= len(self.args[action]):
      return self.args[action][pos - 1]
    else:
      return None
  
  def action_check(self):
    if execute('lxc-checkconfig') == 0:
      print("LXC: " + self.ok)
    else:
      print("LXC: " + self.fail)
      sys.exit(1)
    print("Arch: ", end='')
    if os.uname()[4] == 'x86_64':
      print(self.ok)
    else:
      print(self.fail)
      print("You're not running a 64bits OS, you will not be able to build x86_64 package.", file = sys.stderr)
      print("Please, run a Salix 64bits to make packages.", file = sys.stderr)
      sys.exit(1)
    print("bridge utils: ", end='')
    if execute("/usr/sbin/brctl --help >/dev/null 2>&1") == 0:
      print(self.ok)
    else:
      print(self.fail)
      print("brctl could not be found, please install bridge-utils.", file = sys.stderr)
      sys.exit(1)
    print("rc.local: ", end='')
    if execute("grep -q lxcbr0 /etc/rc.d/rc.local") == 0:
      print(self.ok)
    else:
      print(self.fail)
      print("rc.local seems not to contain the needed preparation for LXC Bridge.", file = sys.stderr)
      print("Please, launch the prepare action.", file = sys.stderr)
      sys.exit(1)
    print("Bridge: ", end='')
    if execute("/sbin/ifconfig|grep -q 'lxcbr0:'") == 0:
      print(self.ok)
    else:
      print(self.fail)
      print("lxcbr0 bridge interface seems not to be configured.", file = sys.stderr)
      print("Please, run /etc/rc.d/rc.local to install it.", file = sys.stderr)
      sys.exit(1)
  
  def action_prepare(self):
    check_root()
    def check_netdevice(v):
      return os.path.exists('/sys/class/net/{0}/type'.format(v)) and int(cat('/sys/class/net/{0}/type'.format(v))) < 256
    ext_iface = read_info("What is your Internet device (wlan0 or eth0 for example)", check = check_device)
    with open('/etc/rc.d/rc.local', 'a') as f:
      f.write("""# salixPackaging
networkBase={network_base}
extIface={ext_iface}
brctl addbr lxcbr0
brctl setfd lxcbr0 0
ifconfig lxcbr0 $networkBase.1 netmask 255.255.255.0 promisc up
iptables -t nat -A POSTROUTING -s $networkBase.0/24 -o $extIface -j MASQUERADE
echo 1 > /proc/sys/net/ipv4/ip_forward
""".format(network_base = self.network_base, ext_iface = ext_iface))
    with open('/etc/rc.d/rc.local_shutdown', 'a') as f:
      f.write("""# salixPackaging
ifconfig lxcbr0 down
brctl delbr lxcbr0
""")
    execute("brctl addbr lxcbr0 && brctl setfd lxcbr0 0 && ifconfig lxcbr0 {network_base}.1 netmask 255.255.255.0 promisc up && iptables -t nat -A POSTROUTING -s {network_base}.0/24 -o {ext_iface} -j MASQUERADE".format(network_base = self.network_base, ext_iface = ext_iface))
    writefile('/proc/sys/net/ipv4/ip_forward', '1')
    touchfile(self.cfg_file)
    os.chmod(self.cfg_file, '0666')
    print("Bridge interface {clgreen}lxcbr0{cnone} configured. Using IP {clgreen}{network_base}.1{cnone}.".format(network_base = self.network_base, cnone = Colors.none, clgreen = Colors.lgreen))
  def action_register(self):
    print("""
Packager Information
====================

Please give some information about yourself and about your remote repository.
If you don't have a remote repository to hold your packages, please send an
email to the ML http://lists.sourceforge.net/lists/listinfo/salix-main in
order to have a space at people.salixos.org.
If you never already made some packages for Salix, take a look here:
http://docs.salixos.org/wiki/Packaging_rules

Hit Ctrl+C to abort.
""")
    name = read_info('Name', check = self.check_notnull)
    email = read_info('Email', check = self.check_notnull)
    tag = ''.join([n[0].lower() for n in name.replace('-', ' ').split()])
    tag = read_info('Package tag', tag)
    user = os.path.basename(os.path.expanduser('~'))
    url = read_info('Remote URL', 'http://people.salixos.org/{user}/salix'.format(user = user), self.check_url)
    scpuri = read_info('SCP URI for Rsync', 'simplynux.net:www/salix', self.check_scp_uri)
    schema = read_info('Schema location', '$pkgname/$pkgver-$arch-$pkgrel', self.check_notnull)
    token = read_info('Your Sourceforge bearer token authentication is needed.\nYou can make one on https://sourceforge.net/auth/oauth/\nBearer Token', check = self.check_notnull)
    with open(self.cfg_file, 'w') as f:
      f.write("pkgr_name={0}\n".format(name))
      f.write("pkgr_email={0}\n".format(email))
      f.write("pkgr_tag={0}\n".format(tag))
      f.write("pkgr_url={0}\n".format(url))
      f.write("pkgr_scpuri={0}\n".format(scpuri))
      f.write("pkgr_schema={0}\n".format(schema))
      f.write("pkgr_user={0}\n".format(user))
      f.write("pkgr_uid={0}\n".format(os.getuid()))
      f.write("pkgr_token={0}\n".format(token))
  
  def read_config(self):
    with open(self.cfg_file, 'r') as f:
      for l in f.readlines():
        if l and not l.startswith('#') and '=' in l:
          k, v = l.strip().split('=', 2)
          setattr(self, k, v)
  def check_registered(self):
    ret = True
    try:
      if not 'pkgr_name=' in cat(self.cfg_file):
        ret = False
    except IOError:
      ret = False
    if not ret:
      print('You should first register as a packager.', file = sys.stderr)
      sys.exit(1)
  
  def action_install(self):
    check_root()
    self.check_registered()
    ver = self.getarg('install', 1)
    arch = self.getarg('install', 2)
    self.check_arch(arch)
    print('Creating LXC Salix {ver} - {arch}'.format(salix = salix, ver = ver))
    # find next number for IP and Mac address
    n = len(self.find_installed_salix())
    # host start at 1, so next add +2
    numip = n + 2
    nummac = '{0:02x}'.format(numip) # hexa
    conf = tempfile.mkstemp()
    execute('sed -r "s/@NUMIP@/{numip}/; s/@NUMMAC@/{nummac}/;" lxc-default.conf > {conf}'.format(numip = numip, nummac = nummac, conf = conf))
    name = 'salixpkg-{ver}-{arch}'.format(salix = salix, ver = ver)
    if execute('lxc-create -n {name} -f {conf} -t lxc-salix -- --arch={arch} --release={ver}'.format(name = name, conf = conf, salix = salix, ver = ver)) != 0:
      os.remove(conf)
      print('Cannot create the LXC.', file = sys.stderr)
      sys.exit(1)
    else:
      os.remove(conf)
      self.read_config()
      execute('chroot /var/lib/lxc/{name}/rootfs sh -c "echo \'pkg:pkg:{pkgr_uid}:users::/home/pkg:/bin/bash\'|/usr/sbin/newusers"'.format(name = name, pkgr_uid = self.pkgr_uid))
      execute('chroot /var/lib/lxc/{name}/rootfs /usr/sbin/usermod -a -G lp,wheel,floppy,audio,video,cdrom,plugdev,power,netdev,scanner pkg'.format(name = name))
      os.chmod('/var/lib/lxc/{name}/rootfs/etc/rc.d/rc.sshd'.format(name = name), '0755')
      for d in ('/var/lib/lxc/{name}/rootfs/root/.ssh', '/var/lib/lxc/{name}/rootfs/home/pkg/.ssh'):
        os.makedirs(d.format(name = name))
        os.chmod(d.format(name = name), '0700')
      for f in ('/var/lib/lxc/{name}/rootfs/root/.ssh/authorized_keys', '/var/lib/lxc/{name}/rootfs/home/pkg/.ssh/authorized_keys'):
        touchfile(f.format(name = name))
      execute('chroot /var/lib/lxc/{name}/rootfs chown -R pkg: /home/pkg/.ssh'.format(name = name))
      for sec in ('rsa', 'dsa'):
        if os.path.exists('/home/{pkgr_user}/.ssh/id_{sec}.pub'.format(pkgr_user = self.pkgr_user, sec = sec)):
          for f in ('/var/lib/lxc/{name}/rootfs/root/.ssh/authorized_keys', '/var/lib/lxc/{name}/rootfs/home/pkg/.ssh/authorized_keys'):
            shutil.copyfile('/home/{pkgr_user}/.ssh/id_{sec}.pub'.format(pkgr_user = self.pkgr_user, sec = sec), f.format(name = name))
          break
      # local repository
      localrepo = '/var/lib/lxc/{name}/rootfs/usr/local/sbin/localrepo'.format(name = name)
      wget(self.localrepo_url, filename = localrepo)
      os.chmod(localrepo, '0755')
      # script to install deps
      installdeps = '/var/lib/lxc/{name}/rootfs/usr/local/sbin/installdeps'.format(name = name)
      writefile(installdeps, """#!/bin/sh
set -e
if [ -n "$1" ]; then
  /usr/sbin/slapt-get -u
  pkgs=''
  for p in $(echo "$1"|tr ',' ' '); do
    if echo "$p" | grep -q '|'; then
      for p2 in $(echo "$p"|tr '|' ' '); do
        /usr/sbin/slapt-get --filelist $p2 > /dev/null && break
        pkgs="$pkgs $p2"
        break
      done
    else
      pkgs="$pkgs $p"
    fi
  done
  /usr/sbin/slapt-get -i $pkgs
fi
""")
      os.chmod(installdeps, '0755')
      if execute('lxc-start -d -n {name}'.format(name = name)) == 0:
        print("LXC started.")
        time.sleep(3) # ensure all is started in the container
        execute('chroot /var/lib/lxc/{name}/rootfs /usr/local/sbin/localrepo -c'.format(name = name))
      else:
        print("Cannot start the LXC.", file = sys.stderr)
        sys.exit(1)
  
  def find_installed_salix(self):
    return [l for l in get_exec("lxc-ls -1|sed -rn '/^salixpkg-/{s/^salixpkg-//;p}'|sort").split("\n") if l]
  def check_numlxc(self):
    if not self.find_installed_salix():
      print("You should first install a Salix LXC version.", file = sys.stderr)
      sys.exit(1)
  
  def action_listinstalled(self):
    for s in self.find_installed_salix():
      salix, ver = s.split('-', 2)
      print(' - {salix}, {ver}'.format(salix = salix, ver = ver))
  
  def action_remove(self):
    check_root()
    self.check_registered()
    ver = self.getarg('remove', 1)
    arch = self.getarg('remove', 2)
    self.check_arch(arch)
    print('Removing LXC Salix {ver} - {arch}'.format(ver = ver, arch = arch))
    execute('lxc-stop -n salixpkg-{ver}-{arch} && lxc-destroy -n salixpkg-{ver}-{arch}'.format(ver = ver, arch = arhc))
  
  def action_create(self):
    self.check_registered()
    self.check_numlxc()
    print("""\
Package creation
================""")
    pkg_name = read_info('Package name', check = self.check_notnull)
    if os.path.exists(os.path.join('src', pkg_name)):
      # Package already exists so we must just ask to create it for missing LXC Salix version
      already = []
      new = []
      for salix_ver in [lxc.split('-', 2)[0] for lxc in self.find_installed_salix()]:
        if os.path.exists('src/{name}/{sver}'.format(name = pkg_name, sver = salix_ver)):
          already.append(salix_ver)
        else:
          new.append(salix_ver)
      if not new:
        print("Package already exists and no new Salix version found", file = sys.stderr)
        sys.exit(1)
      else:
        salix_ver_ref = sorted(already)[-1]
        print("Package found in Salix version {0}.".format(salix_ver_ref))
        print("Install it into {0}.".format(','.join(new)))
        pkg_ver = cat('src/{name}/{sver}/version'.format(name = pkg_name, sver = salix_ver_ref))
        for salix_ver in new:
          self.copy_package_build(pkg_name, pkg_ver, salix_ver_ref, salix_ver, True)
        print("Done.")
    else:
      pkg_arch = read_choice('Package architectures', ['all', 'noarch', 'arm', 'i486', 'x86_64'], 'all')
      pkg_url = read_info('Home page (SKIP to skip)', check = self.check_url)
      if pkg_url == 'SKIP':
        pkg_url = ''
      pkg_dl_url = read_info('Download URL page (SKIP to skip)', check = self.check_url)
      if pkg_dl_url == 'SKIP':
        pkg_dl_url = ''
      if pkg_dl_url:
        pkg_check_schema = None
        choices = [os.path.basename(t) for t in sorted(glob('templates/version/*'))]
        while True:
          while not pkg_check_schema:
            pkg_check_schema = read_choice("Latest version check schema.\nChoose from", choices + ['custom', 'help'], 'help')
            ctx = locals()
            if pkg_check_schema == 'custom':
              print("""\
A custom pattern is a filter on the HTML download page
in order to find the latest stable version.
Example:
  sed -rn 'FIXME'|grep -v 'alpha\|beta\|rc'|sort -rV""")
              pkg_check_pattern = read_info('Custom pattern', check = self.check_notnull)
            elif pkg_check_schema == 'help':
              for c in choices:
                execfile('templates/version/{tpl}'.format(tpl = c), {}, ctx)
                print("{schema}: {version_pattern}\n    {help_text}".format(schema = c, version_pattern = ctx.version_pattern, help_text = ctx.help_text))
              pkg_check_schema = None
            else:
              execfile('templates/version/{tpl}'.format(tpl = pkg_check_schema), {}, ctx)
              pkg_check_pattern = ctx.version_pattern
          print("Pattern: {pattern}".format(pattern = pkg_check_pattern))
          pkg_versions = self.find_all_versions(pkg_dl_url, pkg_check_pattern)
          print("Versions found: {vers}".format(vers = ','.join(pkg_versions)))
          if read_choice('Pattern ok', ['y', 'n'], 'y') == 'y':
            break
        pkg_stable = read_choice('Allow betas versions', ['y', 'n'], 'n') == 'n'
        pkg_ver = self.find_latest_version(pkg_versions, pkg_stable)
        print("Latest version found: {ver}".format(ver = pkg_ver))
        if read_choice('Use this version', ['y', 'n'], 'y') == 'n':
          pkg_ver = read_info('Then, which specific version', pkg_ver, self.check_notnull)
          pkg_fixver = True
        else:
          pkg_fixver = False
        pkg_md5 = self.get_md5sum_links(pkg_dl_url)
      else:
        pkg_ver = read_info('Version', check = self.check_notnull)
        pkg_check_schema = 'custom'
        pkg_check_pattern = ''
        pkg_md5 = ''
        pkg_stable = False
        pkg_fixver = True
      pkg_build_schema = read_choice('Build schema', [os.path.basename(f) for f in glob('templates/build/*')], 'configure')
      salix_ver_ref = ''
      for salix_ver in [lxc.split('-', 2)[0] for lxc in self.find_installed_salix()]:
        if salix_ver_ref:
          self.copy_package_build(pkg_name, pkg_ver, salix_ver_ref, salix_ver, False)
        else:
          self.store_package_info(salix_ver, pkg_name, pkg_arch, pkg_url, pkg_dl_url, pkg_check_schema, pkg_check_pattern, pkg_md5, pkg_ver, pkg_stable, pkg_fixver, pkg_build_schema)
          salix_ver_ref = salix_ver

  def get_pattern_func(self, pattern):
    ctx = locals()
    exec(pattern, globals(), ctx)
    if not 'fpattern' in ctx:
      print('pattern file should define fpattern(content) python function', file = sys.stderr)
      sys.exit(1)
    return ctx['fpattern']

  def find_all_versions(self, url, pattern, md5ref):
    """
    Returns a list of versions.
    "up to date:md5" or "changed:md5" for md5 checks
    """
    if not url:
      return []
    content = ['']
    def wget_func(line):
      content[0] += line
    wget(url, func = wget_func, quiet = True)
    content = content[0].replace(r"'", r"'\''")
    versions = get_exec("echo '{0}'|{1}".format(content, pattern)).split('\n')
    if versions and [x for x in versions if 'MD5:' in x]:
      md5 = versions[0][len('MD5:'):]
      if md5 == md5ref:
        return ['up to date:' + md5]
      else:
        return ['changed:' + md5]
    else:
      return sort_software_versions(versions)

  def find_latest_version(self, versions, stable = True):
    """
    Returns the version or "up to date:md5" or "changed:md5"
    versions are sorted in reveres order
    if stable = True return only a stable version, or else search from all versions
    """
    if len(versions) == 1 and ':' in versions[0]:
      return versions[0]
    else:
      if stable:
        versions = [v for v in versions if not re.search(r'alpha|beta|m[0-9]|rc', v)]
      if versions:
        return versions[0]
      else:
        return None

  def get_md5sum_links(self, url):
    contentlinks = ''
    def filter_links(line):
      if '<a href=' in line and 'http://' in line:
        contentlinks += line
    wget(url, func = filter_links, quiet = True)
    return md5sum(contentlinks)

  def store_package_info(self, salix_ver, pkg_name, pkg_arch, pkg_url, pkg_dl_url, pkg_check_schema, pkg_check_pattern, pkg_md5, pkg_ver, pkg_stable, pkg_fixver, pkg_build_schema):
    os.makedirs('src/{name}/{sver}'.format(name = pkg_name, sver = salix_ver))
    with open('src/{name}/arch'.format(name = pkg_name)) as f:
      f.write(pkg_arch)
    with open('src/{name}/url'.format(name = pkg_name)) as f:
      f.write(pkg_url)
    with open('src/{name}/dlurl'.format(name = pkg_name)) as f:
      f.write(pkg_dl_url)
    with open('src/{name}/md5sum'.format(name = pkg_name)) as f:
      f.write(pkg_md5)
    with open('src/{name}/schema'.format(name = pkg_name)) as f:
      f.write(pkg_check_schema)
    with open('src/{name}/pattern'.format(name = pkg_name)) as f:
      f.write(pkg_check_pattern)
    with open('src/{name}/buildschema/'.format(name = pkg_name)) as f:
      f.write(pkg_build_schema)
    with open('src/{name}/{sver}/version'.format(name = pkg_name, sver = salix_ver)) as f:
      f.write(pkg_ver)
    with open('src/{name}/{sver}/stable'.format(name = pkg_name, sver = salix_ver)) as f:
      f.write(pkg_stable)
    with open('src/{name}/{sver}/fixversion'.format(name = pkg_name, sver = salix_ver)) as f:
      f.write(pkg_fixver)
    self.store_package_build(pkg_name, pkg_ver, salix_ver)
    print("Information for package {cgreen}{pkg_name}{cnone} has been stored for {salix_ver}.".format(pkg_name = pkg_name, salix_ver = salix_ver, cgreen = Colors.green, cnone = Colors.none))

  def store_package_build(self, pkg_name, pkg_ver, salix_ver):
    self.read_config()
    pkg_arch = cat('src/{name}/arch'.format(name = pkg_name))
    pkg_url = cat('src/{name}/url'.format(name = pkg_name))
    dl_url = cat('src/{name}/dlurl'.format(name = pkg_name))
    schema = cat('src/{name}/schema'.format(name = pkg_name))
    pkg_dl_url = '{url}/{name}-{ver}.tar.gz'.format(url = dl_url, name = pkg_name, ver = pkg_ver)
    if schema != 'custom':
      ctx = locals()
      execfile('templates/version/{tpl}'.format(tpl = schema), {}, ctx)
      pkg_dl_url = ctx.download_pattern
    pkg_build_schema = cat('src/{name}/buildschema'.format(name = pkg_name))
    pkgr_email_dot = self.pkgr_email.replace('.', '~dot~').replace('@', '~at~')
    arch_var = ''
    if pkg_arch != 'all':
      arch_var = 'arch={arch}'.format(arch = pkg_arch)
    pkgr_schema_protected = self.pkgr_schema.replace('$arch', '\\$arch').replace('\\', r'\\\\')
    os.makedirs('src/{name}/{sver}/{ver}'.format(name = pkg_name, sver = salix_ver, ver = pkg_ver))
    pkg_ver_slackware = re.sub(r'[-_]', r'.', pkg_ver) # Slackware does not allow hyphens or underscores in package version
    tpl = cat('templates/SLKBUILD')
    with open('src/{name}/{sver}/{ver}/SLKBUILD'.format(name = pkg_name, sver = salix_ver, ver = pkg_ver), 'w') as f:
      f.write(tpl.format(\
          pname = self.pkgr_name,\
          pemail = pkgr_email_dot,\
          name = pkg_name,\
          ver = pkg_ver_slackware,\
          rlz = 1,\
          ptag = self.pkgr_tag,\
          archvar = arch_var,\
          dlurl = pkg_dl_url,\
          purl = self.pkgr_url,\
          pschema = pkgr_schema_protected,\
          url = pkg_url,\
          build = cat('templates/build/{0}'.format(pkg_build_schema))\
        ))
    for dep in ('dep', 'makedep', 'sug', 'con'):
      writefile('src/{name}/{sver}/{ver}/{dep}'.format(name = pkg_name, sver = salix_ver, ver = pkg_ver, dep = dep))
    self.args['edit'] = [pkg_name, pkg_ver, salix_ver]
    self.action_edit()

  def copy_package_build(self, pkg_name, pkg_ver, salix_ver, salix_newver, ask):
    os.makedirs('src/{name}/{sver}/{ver}'.format(name = pkg_name, sver = salix_newver, ver = pkg_ver))
    copytree('src/{name}/{sver}/{ver}'.format(name = pkg_name, sver = salix_ver, ver = pkg_ver),\
        'src/{name}/{sver}/{ver}'.format(name = pkg_name, sver = salix_newver, ver = pkg_ver))
    writefile('src/{name}/{sver}/version'.format(name = pkg_name, sver = salix_newver), pkg_ver)
    if ask:
      writefile('src/{name}/{sver}/fixversion'.format(name = pkg_name, sver = salix_newver), read_choice('Use this specific fixed ({ver}) version'.format(ver = pkg_ver), ['y', 'n'], 'n') == 'y')
    else:
      shutil.copy('src/{name}/{sver}/fixversion'.format(name = pkg_name, sver = salix_ver),\
          'src/{name}/{sver}/'.format(name = pkg_name, sver = salix_newver))
    print("Information for package {cgreen}{pkg_name}{cnone} has been stored for {cgreen}{salix_ver}{cnone}.".format(pkg_name = pkg_name, salix_ver = salix_ver, cgreen = Colors.green, cnone = Colors.none))

  def copy_package_ver_build(self, pkg_name, salix_ver, pkg_ver, pkg_newver):
    os.makedirs('src/{name}/{sver}/{ver}'.format(name = pkg_name, sver = salix_ver, ver = pkg_newver))
    copytree('src/{name}/{sver}/{ver}'.format(name = pkg_name, sver = salix_ver, ver = pkg_ver),\
        'src/{name}/{sver}/{ver}'.format(name = pkg_name, sver = salix_ver, ver = pkg_newver))
    slkbuild_file = 'src/{name}/{sver}/{ver}/SLKBUILD'.format(name = pkg_name, sver = salix_ver, ver = pkg_newver)
    slkbuild = cat(sklbuild_file)
    if re.search(r'\n_pkgver=', slkbuild):
      writefile(slkbuild_file, re.sub(r'\n_pkgver=.*', r'\n_pkgver={0}'.format(pkg_newver), slkbuild))
    else:
      writefile(slkbuild_file, re.sub(r'\npkgver=.*', r'\npkgver={0}'.format(pkg_newver), slkbuild))
    print("Information for package {cgreen}{pkg_name}{cnone} has been stored in version {cgreen}{pkg_newver}{cnone}, for Salix $salix_ver.".format(pkg_name = pkg_name, pkgnew_ver = pkgnew_ver, salix_ver = salix_ver, cgreen = Colors.green, cnone = Colors.none))

  def action_pkg_list(self):
    packages = []
    for p in sorted([d for d in os.listdir('src') if not d.startswith('.') and os.path.isdir('src/' + d)]):
      for s in sorted([d for d in os.listdir('src/' + p) if not d.startswith('.') and os.path.isdir('src/{0}/{1}'.format(p, d))]):
        v = cat('src/{0}/{1}/version'.format(p, s))
        packages.append([p, v, s])
    if self.is_interactive():
      # FIXME
      pass
      #show_interactive_list "$packages" "Package,Version,Salix" "$(tput setaf 4),$(tput setaf 2),$(tput setaf 3)" "20*,20,5" "Packages" "H for Help" 'hq'
      #echo choosen=$CHOOSEN_ACTION
    else:
      for pkg in packages:
        print("{pkg} - {ver} ({sver})".format(pkg = pkg[0], ver = pkg[1], sver = pkg[2]))
  
  def action_pkg_info(self):
    pkg_name = self.getarg('pkg_info', 1)
    if not os.path.isdir('src/{0}'.format(pkg_name)):
      sys.exit(1)
    pkg_arch = cat('src/{name}/arch'.format(name = pkg_name))
    pkg_url = cat('src/{name}/url'.format(name = pkg_name))
    pkg_dl_url = cat('src/{name}/dlurl'.format(name = pkg_name))
    pkg_check_schema = cat('src/{name}/schema'.format(name = pkg_name))
    pkg_check_pattern = cat('src/{name}/pattern'.format(name = pkg_name))
    pkg_md5 = cat('src/{name}/md5sum'.format(name = pkg_name))
    pkg_build_schema = cat('src/{name}/buildschema'.format(name = pkg_name))
    print("""\
{cbold}{name}{cnone}
{underline}
arch={clgreen}{arch}{cnone}
url={url}
download url={dl_url}
MD5 sum of the download page={md5}
Schema check for latest version={schema}
Schema pattern={pattern}
Build schema={build_schema}
""".format(name = pkg_name, underline = '=' * len(pkg_name), arch = pkg_arch, url = pkg_url, dl_url = pkg_dl_url, md5 = pkg_md5, schema = pkg_check_schema, pattern = pkg_check_pattern, build_schema = pkg_build_schema, cbold = Colors.bold, clgreen = Colors.lgreen, cnone = Colors.none))
    for salix_ver in sorted([d for d in os.listdir('src/' + pkg_name) if not d.startswith('.') and os.path.isdir('src/{0}/{1}'.format(pkg_name, d))]):
      pkg_ver = cat('src/{0}/{1}/version'.format(pkg_name, salix_ver))
      pkg_stable = cat('src/{0}/{1}/stable'.format(pkg_name, salix_ver))
      pkg_fixver = cat('src/{0}/{1}/fixversion'.format(pkg_name, salix_ver))
      print("""
Versions for {clgreen}{sver}{cnone}
============={underline}
Current version={cbold}{ver}{cnone}
Stable only={cbold}{stable}{cnone}
Fixed version={cbold}{fixver}{cnone}""".format(sver = salix_ver, underline = '=' * len(salix_ver), ver = pkg_ver, stable = pkg_stable, fixver = pkg_fixver, clgreen = Colors.lgreen, cbold = Colors.bold, cnone = Colors.none))
      for v in sorted([d for d in os.listdir('src/{0}/{1}'.format(pkg_name, salix_ver)) if not d.startswith('.') and os.path.isdir('src/{0}/{1}/{2}'.format(pkg_name, salix_ver, d))]):
        m = re.search(r'\npkgrel=([0-9]+).*', cat('src/{0}/{1}/{2}/SLKBUILD'.format(pkg_name, salix_ver, v)))
        rlz = m.group(1)
        print("- version {clgreen}{ver}{cnone}, release {clgreen}{rlz}{cnone}".format(ver = v, rlz = rlz, clgreen = Colors.lgreen, cnone = Colors.none))
  
  def action_edit(self):
    pkg_name = self.getarg('edit', 1)
    pkg_ver = self.getarg('edit', 2)
    salix_ver = self.getarg('edit', 3)
    slkbuild = 'src/{0}/{1}/{2}/SLKBUILD'.format(pkg_name, salix_ver, pkg_ver)
    if not os.path.exists(slkbuild):
      sys.exit(1)
    doedit = True
    while doedit:
      os.system('vim {0}'.format(slkbuild))
      doedit = bool(re.search(r'FIXME', cat(slkbuild)))
      if doedit:
        raw_input("There are still some FIXME in the SLKBUILD, please correct them before continue.")
    if read_choice("Do you want to edit the local files and dependencies (shell)", ['y', 'n'], 'n') == 'y':
      os.system('cd src/{0}/{1}/{2} && sh'.format(pkg_name, salix_ver, pkg_ver))
  
  def action_verify(self):
    pkg_name = self.getarg('verify', 1)
    salix_ver = self.getarg('verify', 2)
    if not os.path.isdir('src/{0}/{1}'.format(pkg_name, salix_ver)):
      sys.exit(1)
    pkg_dl_url = cat('src/{0}/dlurl'.format(pkg_name))
    pkg_check_pattern = cat('src/{0}/pattern'.format(pkg_name))
    pkg_md5 = cat('src/{0}/md5sum'.format(pkg_name))
    pkg_stable = cat('src/{0}/{1}/stable'.format(pkg_name, salix_ver))
    pkg_new_ver = self.find_latest_version(self.find_all_versions(pkg_dl_url, pkg_check_pattern, pkg_md5), pkg_stable)
    pkg_ver = cat('src/{0}/{1}/version'.format(pkg_name, salix_ver))
    pkg_fixver = cat('src/{0}/{1}/fixversion'.format(pkg_name, salix_ver))
    if pkg_ver == pkg_new_ver:
      print("{clgreen}Up to date{cnone} ({clcyan}{pkg_new_ver}{cnone})".format(pkg_new_ver = pkg_new_ver, clgreen = Colors.lgreen, clcyan = Colors.lcyan, cnone = Colors.none))
    elif pkg_new_ver and 'up to date:' in pkg_new_ver:
      print("{cyellow}Seems up to date{cnone} ({clcyan}MD5:{md5}{cnone})".format(md5 = pkg_new_ver.split(':', 2)[1], cyellow = Colors.yellow, clcyan = Colors.lcyan, cnone = Colors.none))
    elif pkg_new_ver and 'changed:' in pkg_new_ver:
      print("{clmagenta}Seems changed{cnone} ({clcyan}MD5:{md5}{cnone})".format(md5 = pkg_new_ver.split(':', 2)[1], clmagenta = Colors.lmagenta, clcyan = Colors.lcyan, cnone = Colors.none))
    elif pkg_fixver:
      print("{cgreen}Fixed version to {pkg_ver}{cnone} ({clcyan}{pkg_new_ver}{cnone})".format(pkg_ver = pkg_ver, pkg_new_ver = pkg_new_ver, cgreen = Colors.green, clcyan = Colors.lcyan, cnone = Colors.none))
    else:
      print("{clred}Need to upgrade from version {cblue}{pkg_ver}{clred} to {clcyan}{pkg_new_ver}{cnone}".format(pkg_ver = pkg_ver, pkg_new_ver = pkg_new_ver, clred = Colors.lred, cblue = Colors.blue, clcyan = Colors.lcyan, cnone = Colors.none))
  
  def action_verify_all(self):
    pkg = self.getarg('verify_all', 1)
    if not pkg:
      pkg_list = sorted([d for d in os.listdir('src') if not d.startswith('.') and os.path.isdir('src/' + d)])
    else:
      if not os.path.isdir('src/{0}'.format(pkg)):
        sys.exit(1)
      pkg_list= [pkg]
    for p in pkg_list:
      for s in sorted([d for d in os.listdir('src/' + p) if not d.startswith('.') and os.path.isdir('src/{0}/{1}'.format(p, d))]):
        print('{0} - {1}: '.format(p, s), end = '')
        self.args['verify'] = [p, s]
        self.action_verify()
  
  def action_update(self):
    pkg_name = self.getarg('update', 1)
    salix_ver = self.getarg('update', 2)
    if not os.path.isdir('src/{0}/{1}'.format(pkg_name, salix_ver)):
      sys.exit(1)
    stable = cat('src/{0}/{1}/stable'.format(pkg_name, salix_ver))
    pkg_fixver = cat('src/{0}/{1}/fixversion'.format(pkg_name, salix_ver))
    if pkg_fixver:
      print('{clred}Cannot update, fix version requested{cnone}'.format(clred = Colors.lred, cnone = Colors.none), file = sys.stderr)
      sys.exit(1)
    else:
      dlurl = cat('src/{0}/dlurl'.format(pkg_name))
      pat = cat('src/{0}/pattern'.format(pkg_name))
      oldver = cat('src/{0}/{1}/version'.format(pkg_name, salix_ver))
      ver = self.find_latest_version(self.find_all_versions(dlurl, pat), stable)
      if ':' in ver:
        md5 = ver.split(':', 2)[1]
      else:
        md5 = self.get_md5sum_links(dlurl)
      writefile('src/{0}/md5sum'.format(pkg_name), md5)
      writefile('src/{0}/{1}/version'.format(pkg_name, salix_ver), ver)
      if not ':' in ver:
        self.copy_package_ver_build(pkg_name, salix_ver, oldver, ver)
      print('{clgreen}Updated to version {clcyan}{ver}{cnone}'.format(ver = ver, clgreen = Colors.lgreen, clcyan = Colors.lcyan, cnone = Colors.none))
  
  def action_build(self):
    self.check_registered()
    pkg_name = self.getarg('build', 1)
    pkg_ver = self.getarg('build', 2)
    salix_ver = self.getarg('build', 3)
    salix_arch = self.getarg('build', 4)
    numjobs = self.getarg('build', 5)
    if not os.path.exists('src/{0}/{1}/{2}/SLKBUILD'.format(pkg_name, salix_ver, pkg_ver)):
      sys.exit(1)
    found = False
    for sver, sarch in [salix.split('-') for salix in self.find_installed_salix()]:
      if sver == salix_ver and sarch == salix_arch:
        found = True
        break
    if not found:
      print('LXC Salix version {ver} and arch {arch} has not been installed.'.format(ver = salix_ver, arch = salix_arch), file = sys.stderr)
      sys.exit(1)
    deps = []
    makedep = 'src/{0}/{1}/{2}/makedep'.format(pkg_name, salix_ver, pkg_ver)
    dep = 'src/{0}/{1}/{2}/dep'.format(pkg_name, salix_ver, pkg_ver)
    if os.path.exists(makedep):
      strdep = cat(makedep)
      if strdep:
        deps.extend(strdep.split(','))
    if os.path.exists(dep):
      strdep = cat(dep)
      if strdep:
        deps.extend(strdep.split(','))
    with open('queue', 'a') as f:
      f.write('{0},{1},{2},{3},{4},{5}\n'.format(pkg_name, pkg_ver, salix_ver, salix_arch, numjobs, ','.join(deps)))
    print('{0}-{1} for {2}-{3} added to the queue.'.format(pkg_name, pkg_ver, salix_ver, salix_arch))
  
  def action_queue(self):
    self.check_registered()
    self.check_numlxc()
    m = 'queue_{0}'.format(self.args['queue'])
    if m in self.args:
      getattr(self, m)(self.args[m])
    else:
      getattr(self, m)()
  def queue_list(self):
    if self.is_interactive():
      # FIXME
      pass
    else:
      for l in cat('queue').split('\n'):
        if not l:
          continue
        name, ver, sver, arch, jobs, deps = l.split(',', 5)
        print('{0}-{1} on {2}-{3}'.format(name, ver, sver, arch))
  def queue_clear(self):
    writefile('queue')
  def queue_remove(self, remove_params):
    lines = ''
    for param in remove_params:
      if '-' in param:
        first, last = param.split('-', 2)
        for subline in range(first, last + 1):
          lines += subline + 'd;'
      else:
        lines += param + 'd;'
    execute("sed -i '{0}' queue".format(lines))
  def queue_run(self):
    self.read_config()
    queue = cat('queue').split('\n')
    while queue and queue[0]:
      build_item = queue[0]
      del(queue[0])
      pkg_name, pkg_ver, salix_ver, salix_arch, numjobs, deps = build_item.split(',', 5)
      pkg_arch = cat('src/{0}/arch'.format(pkg_name))
      if pkg_arch == 'all':
        pkg_arch = salix_arch
      lxc_name = 'salixpkg-{0}-{1}'.format(salix_ver, salix_arch)
      lxc_root = '/var/lib/lxc/{0}/rootfs'.format(lxc_name)
      lxc_build = '/home/pkg/build/{0}-{1}'.format(pkg_name, pkg_ver)
      src_dir = 'src/{0}/{1}/{2}'.format(pkg_name, salix_ver, pkg_ver)
      print("\n{clcyan}Building {pkg_name}-{pkg_ver} for {salix_ver}-{salix_arch}...{cnone}".format(pkg_name = pkg_name, pkg_ver = pkg_ver, salix_ver = salix_ver, salix_arch = salix_arch, clcyan = Colors.lcyan, cnone = Colors.none))
      # remove old build if any
      try:
        shutil.rmtree(lxc_root + lxc_build)
      except:
        pass
      os.makedirs(lxc_root + lxc_build)
      copytree(src_dir, lxc_root + lxc_build)
      lxc_ip = re.search(r'lxc\.network\.ipv4 *= *(.+)/.+', cat('/var/lib/lxc/{0}/config'.format(lxc_name))).group(1)
      if deps:
        if execute('ssh -t root@{ip} "installdeps \'{deps}\'"'.format(ip = lxc_ip, deps = deps)) != 0:
          print("""{clred}Unable to install the dependencies for {pkg_name}-{pkg_ver} for {salix_ver}-{salix_arch}{cnone}
Deps list: {cred}{deps}{cnone}""".format(pkg_name = pkg_name, pkg_ver = pkg_ver, salix_ver = salix_ver, salix_arch = salix_arch, deps = deps, clred = Colors.lred, cred = Colors.red, cnone = Colors.none), file = sys.stderr)
          sys.exit(1)
      # building the package
      if execute('ssh -t pkg@{ip} "cd {dir}; LANG=en_US.utf8 numjobs={jobs} fakeroot slkbuild -X"'.format(ip = lxc_ip, dir = lxc_build, jobs = numjobs)) == 0:
        pkg_rel = re.search(r'\npkgrel=([0-9]+.*)', cat('{0}{1}/SLKBUILD'.format(lxc_root, lxc_build))).group(1)
        pkg_ver_slackware = pkg_ver.replace('-', '.').replace('_', '.')
        pkg_base_name = '{0}-{1}-{2}-{3}'.format(pkg_name, pkg_ver_slackware, pkg_arch, pkg_rel)
        # create .dep, .sug and .con files if non empty
        for ext in ('dep', 'sug', 'con'):
          f = '{0}{1}/{2}'.format(lxc_root, lxc_build, ext)
          try:
            if cat(f):
              os.rename(f, '{0}{1}/{2}.{3}'.format(lxc_root, lxc_build, pkg_base_name, ext))
            else:
              os.remove(f)
          except IOError:
            pass
        makedep = '{0}{1}/makedep'.format(lxc_root, lxc_build)
        try:
          os.remove(makedep)
        except IOError:
          pass
        # add the package to the localrepo
        if not re.search(r'/localrepo/', '{0}/etc/slapt-get/slapt-getrc'.format(lxc_root)):
          execute('ssh -t root@{ip} "localrepo -s"'.format(ip = lxc_ip))
        pkg_ext = None
        for ext in ('txz', 'tgz'):
          if os.path.exists('{0}{1}/{2}.{3}'.format(lxc_root, lxc_build, pkg_base_name, ext)):
            pkg_ext = ext
            break
        if not pkg_ext:
          sys.exit(1)
        execute('ssh -t root@{ip} "localrepo -a {build}/{name}.{ext}"'.format(ip = lxc_ip, build = lxc_build, name = pkg_base_name, ext = pkg_ext))
        bin_dir = os.path.join('bin', self.pkgr_schema\
            .replace('$pkgname', '{pkgname}')\
            .replace('$pkgver', '{pkgver}')\
            .replace('$arch', '{arch}')\
            .replace('$pkgrel', '{pkgrel}')\
            .format(pkgname = pkg_name, pkgver = pkg_ver_slackware, arch = pkg_arch, pkgrel = pkg_rel))
        os.makedirs(bin_dir)
        copytree('{0}{1}'.format(lxc_root, lxc_build), bin_dir)
        print("{clgreen}Package {pkg_name}-{pkg_ver} building DONE for {salix_ver}-{salix_arch}{cnone}".format(pkg_name = pkg_name, pkg_ver = pkg_ver, salix_ver = salix_ver, salix_arch = salix_arch, clgreen = Colors.lgreen, cnone = Colors.none))
        writefile('queue', '\n'.join(queue))
      else:
        print("{clred}Package {pkg_name}-{pkg_ver} building FAILED for {salix_ver}-{salix_arch}{cnone}".format(pkg_name = pkg_name, pkg_ver = pkg_ver, salix_ver = salix_ver, salix_arch = salix_arch, clred = Colors.lred, cnone = Colors.none), file = sys.stderr)
        if read_choice('Would you like to edit the package', ['y', 'n'], 'y') == 'y':
          self.args['edit'] = [pkg_name, pkg_ver, salix_ver]
          self.action_edit()
        break
    if queue:
      return 1
    else:
      return 0
  
  def action_dedup(self):
    for item in os.listdir('bin'):
      files = []
      for root, dirnames, filenames in os.walk(os.path.join('bin', item)):
        files.extend(map(lambda fn: os.path.join(root, fn), [f for f in filenames if not f[0] == '.']))
      DeDup(linktype = 'soft', use_time = False).deduplicate(files)

  def action_rsync(self):
    self.read_config()
    os.mkdir('remote')
    ok = True
    try:
      if execute('sshfs -o uid=$(id -u) -o gid=$(id -g) "{0}" remote'.format(self.pkgr_scpuri)) == 0:
        print("Connection ok, Synchronizing...")
        execute('rsync -rvhlH --numeric-ids --del --inplace --times --progress --stats bin/ remote')
        os.sync()
      else:
        ok = False
    finally:
      time.sleep(1)
      execute('fusermount -u remote')
      time.sleep(1)
      os.rmdir('remote')
    if ok:
      print("{clgreen}Synchronization done{cnone}".format(clgreen = Colors.lgreen, cnone = Colors.none))
    else:
      print("{clred}Cannot connect, please check your configuration for {uri}{cnone}".format(uri = self.pkgr_scpuri, clred = Colors.lred, cnone = Colors.none), file = sys.stderr)
      sys.exit(1)
  
  def action_ticket(self):
    self.check_registered()
    pkg_name = self.getarg('ticket', 1)
    salix_ver = self.getarg('ticket', 2)
    ticket_id = self.getarg('ticket', 3)
    version = 'src/{0}/{1}/version'.format(pkg_name, salix_ver)
    if not os.path.exists(version):
      sys.exit(1)
    pkg_ver = cat(version)
    pkg_ver_slackware = pkg_ver.replace('-', '.').replace('_', '.')
    pkg_rel = re.search(r'\npkgrel=([0-9]+.*)', cat('src/{0}/{1}/{2}/SLKBUILD'.format(pkg_name, salix_ver, pkg_ver))).group(1)
    pkg_url = cat('src/{0}/url'.format(pkg_name))
    pkg_arch = cat('src/{0}/arch'.format(pkg_name))
    if pkg_arch == 'all':
      arches = ['i486', 'x86_64', 'arm']
    else:
      arches = [pkg_arch]
    self.read_config()
    if not ticket_id or ticket_id == 'new':
      ticket_id = 'new'
      tickettype = read_choice('Ticket Type', ['New', 'Upgrade', 'Rebuild', 'Transfer'], 'New', False)
      importance = read_choice('Importance', ['Trivial', 'Minor', 'Normal', 'Major', 'Criticial'], 'Normal', False)
    message = read_info('Short message')
    desc = ''
    if message:
      desc = '*{0}*\n'.format(message.replace('*', '\\*'))
    desc += '**Homepage:**\n{0}\n'.format(pkg_url)
    for arch in arches:
      bin_dir = self.pkgr_schema\
          .replace('$pkgname', '{pkgname}')\
          .replace('$pkgver', '{pkgver}')\
          .replace('$arch', '{arch}')\
          .replace('$pkgrel', '{pkgrel}')\
          .format(pkgname = pkg_name, pkgver = pkg_ver_slackware, arch = arch, pkgrel = pkg_rel)
      if os.path.isdir(os.path.join('bin', bin_dir)):
        pkg_base = '{0}-{1}-{2}-{3}'.format(pkg_name, pkg_ver_slackware, pkg_arch, pkg_rel)
        desc += '---\n\n**Package {0}:**\n>'.format(arch)
        for ext in ('txz', 'tgz', 'md5', 'src', 'dep', 'sug', 'con'):
          f = '{0}/{1}.{2}'.format(bin_dir, pkg_base, ext)
          if os.path.exists(os.path.join('bin', f)):
            desc += '- <{0}/{1}>\n'.format(self.pkgr_url, f)
        desc += '\n**Log {arch}:**\n><{url}/{dir}/build-{pkg_base}.log>\n\n**Buildscript and source {arch}:**\n>- <{url}/{dir}/SLKBUILD>\n'.format(arch = arch, url = self.pkgr_url, dir = bin_dir, pkg_base = pkg_base)
        bin_bin_dir = os.path.join('bin', bin_dir)
        for f in sorted([f for f in os.listdir(bin_bin_dir) if not os.path.isdir(os.path.join(bin_bin_dir, f))]):
          if f.startswith('{0}.'.format(pkg_base)) or f.startswith('build-{0}.log'.format(pkg_name)) or f == 'SLKBUILD':
            continue
          desc += '- <{0}/{1}/{2}>\n'.format(self.pkgr_url, bin_dir, f)
    print('\n----------\n{cgreen}{desc}{cnone}----------'.format(desc = desc, cgreen = Colors.green, cnone = Colors.none))
    if ticket_id == 'new':
      msg = '\nPosting this'
    else:
      msg = '\nAdding this to ticket {0}'.format(ticket_id)
    if read_choice(msg, ['y', 'n'], 'y') == 'n':
      sys.exit(0)
    base_url = 'https://sourceforge.net'
    ticket_uri = '/p/salix/packages/'
    if ticket_id == 'new':
      try:
        newticket_url = '{0}/rest/p/salix/packages/new'.format(base_url)
        data = urllib.urlencode({
          'access_token' : self.pkgr_token,
          'ticket_form.summary' : '{0}-{1}'.format(pkg_name, pkg_ver),
          'ticket_form.status' : 'open',
          'ticket_form.assigned_to' : '',
          'ticket_form.labels' : '',
          'ticket_form.custom_fields._type' : tickettype,
          'ticket_form.custom_fields._importance' : importance,
          'ticket_form.custom_fields._salix_version' : salix_ver,
          'ticket_form.description' : desc,
        })
        resp = urllib2.urlopen(urllib2.Request(newticket_url, data))
        jsondata = json.loads(''.join(resp.readlines()))
        ticket_id = jsondata['ticket']['ticket_num']
      except:
        ticket_id = None
    else:
      try:
        infoticket_url = '{0}/rest/p/salix/packages/{1}'.format(base_url, ticket_id)
        resp = urllib2.urlopen(urllib2.Request(infoticket_url))
        jsondata = json.loads(''.join(resp.readlines()))
        thread_id = jsondata['ticket']['discussion_thread']['_id']
        postticket_url = '{0}/rest/p/salix/packages/_discuss/thread/{1}/new'.format(base_url, thread_id)
        data = urllib.urlencode({
          'access_token' : self.pkgr_token,
          'text' : desc,
        })
        resp = urllib2.urlopen(urllib2.Request(postticket_url, data))
      except:
        ticket_id = None
    if ticket_id:
      print('Ticket posted: {0}{1}{2}/'.format(base_url, ticket_uri, ticket_id))
    else:
      sys.exit(1)

#################################################

class DeDup(object):
  """
  De-duplicate files using hardlinks or symlinks
  """
  def __init__(self, linktype = 'hard', use_time = True, use_name = False, use_content = True):
    """
    linktype could be 'hard', 'sym' or 'soft'. 'soft' is an alias for 'sym'
    If use_time is True, it will be used as part of the hash.
    If use_name is True, it will be used as part of the hash.
    If use_content is True, a sha1 is used with the content as part of the hash.
    """
    if linktype not in ('hard', 'sym', 'soft'):
      raise Exception('linktype should be hard, sym of soft')
    self.use_hardlink = linktype == 'hard'
    self.use_time = use_time
    self.use_name = use_name
    self.use_content = use_content
    self.max_hash = 128 * 1024
  def _ishardlinkto(self, fs1, fs2):
    return fs1[stat.ST_INO] == fs2[stat.ST_INO] and fs1[stat.ST_DEV] == fs2[stat.ST_DEV]
  def _gethash(self, filename, filestat):
    if not filestat:
      return None
    size = filestat[stat.ST_SIZE]
    if self.use_time:
      time = filestat[stat.ST_MTIME]
    else:
      time = 1
    h = (size ^ time) & (self.max_hash - 1)
    if self.use_name:
      h = unicode(h) + ':' + sha1(os.path.basename(filename))
    if self.use_content:
      try:
        with open(filename, 'rb') as f:
          h = unicode(h) + ':' + sha1(f.read())
      except:
        pass
    return h
  def deduplicate(self, files = []):
    """
    Find same file/content, and deduplicate them using links.
    """
    hashes = {}
    for fn in files:
      if not os.path.isfile(fn):
        # skip non regular files
        continue
      if self.use_hardlink and os.path.islink(fn):
        # skip symlinks
        continue
      try:
        fs = os.stat(fn)
      except:
        fs = None
      h = self._gethash(fn, fs)
      if h:
        if not h in hashes:
          hashes[h] = [(fn, fs)]
        else:
          hashes[h].append((fn, fs))
    for dups in [lst for lst in hashes.values() if len(lst) > 1]:
      if self.use_hardlink:
        fn0, fs0 = dups[0]
        others = dups[1:]
        for fn, fs in others:
          if self._ishardlinkto(fs0, fs):
            break
        else:
          # fn0 is not a hard link to any other
          for fn, fs in others:
            try:
              os.remove(fn)
              os.link(fn0, fn)
            except:
              print("Unexpected error while hardlinking {0} to {1}. You could have lost a file".format(fn, fn0), file = sys.stderr)
      else:
        todel = None
        for i in range(len(dups)):
          fn, fs = dups[i]
          if not todel and not os.path.islink(fn):
            todel = i
        if todel:
          others = dups[:]
          fn0, fs0 = dups[todel]
          del(others[todel])
          for fn, fs in others:
            try:
              os.remove(fn)
              dest = os.path.relpath(fn0, os.path.dirname(fn))
              os.symlink(dest, fn)
            except:
              print("Unexpected error while symlinking {0} to {1}. You could have lost a file".format(fn, fn0), file = sys.stderr)

class SalixAction(argparse.Action):
  def __call__(self, parser, namespace, values, option_string = None):
    setattr(namespace, 'action', self.dest)
    if values:
      setattr(namespace, self.dest, values)
class SalixQueueAction(argparse.Action):
  def __call__(self, parser, namespace, values, option_string = None):
    setattr(namespace, 'action', self.dest)
    setattr(namespace, self.dest, values[0])
    if values[1:]:
      setattr(namespace, 'queue_' + values[0], values[1:])

if __name__ == '__main__':
  os.chdir(os.path.dirname(__file__))
  rootrequired = Colors.wrap('red', '* ')
  parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
    description = """{app} v{ver}
{copyright}
{license}
{author}

Help a packager to manage his/her packages for Salix.
""".format(app = __app__, ver = __version__, copyright = __copyright__, license = __license__, author = __author__),
    epilog = "{0}root privileges required".format(rootrequired))
  parser.add_argument('-V', '--version', action = 'version', version = '{app} v{ver}'.format(app = __app__, ver = __version__),
      help = 'Show the version')
  lxcgroup = parser.add_argument_group('LXC options')
  lxcgroup.add_argument('--check', action = SalixAction, nargs = 0,
      help = 'Sanity check of Host environment.')
  lxcgroup.add_argument('--prepare', action = SalixAction, nargs = 0,
      help = rootrequired + 'Prepare the host to install LXC versions of Salix.')
  lxcgroup.add_argument('--register', action = SalixAction, nargs = 0,
      help = 'Register your information as packager.')
  lxcgroup.add_argument('--install', action = SalixAction, nargs = 2, metavar = ('SALIX_VER', 'ARCH'),
      help = rootrequired + "Install a LXC version of Salix for the specified SALIX_VER and ARCH. ARCH could be 'i486' or 'x86_64'.")
  lxcgroup.add_argument('--list-installed', dest = 'action', action = 'store_const', const = 'listinstalled',
      help = 'List all LXC Salix version installed.')
  lxcgroup.add_argument('--remove', action = SalixAction, nargs = 2, metavar = ('SALIX_VER', 'ARCH'),
      help = rootrequired + 'Remove a LXC Salix version SALIX_VER and arch ARCH.')
  pkggroup = parser.add_argument_group('Package options')
  pkggroup.add_argument('-c', '--create', action = SalixAction, nargs = 0,
      help = 'Create a new package.')
  pkggroup.add_argument('-l', '--pkg-list', action = SalixAction, nargs = 0,
      help = 'Show all packages and their state.')
  pkggroup.add_argument('-p', '--pkg-info', action = SalixAction, nargs = 1, metavar = 'PKG_NAME',
      help = 'Show some information about the PKG_NAME.')
  pkggroup.add_argument('-e', '--edit', action = SalixAction, nargs = 3, metavar = ('PKG_NAME', 'PKG_VER', 'SALIX_VER'),
      help = 'Edit a PKG_NAME SLKBUILD file, version PKG_VER, for Salix SALIX_VER.')
  pkggroup.add_argument('-v', '--verify', action = SalixAction, nargs = 2, metavar = ('PKG_NAME', 'SALIX_VER'),
      help = 'Verify the latest stable version of the PKG_NAME for the Salix SALIX_VER.')
  pkggroup.add_argument('-a', '--verify-all', action = SalixAction, nargs = '?', metavar = 'PKG_NAME',
      help = """Verify the latest stable version on all packages or the package PKG_NAME, for all Salix versions.
Could take some time.""")
  pkggroup.add_argument('-u', '--update', action = SalixAction, nargs = 2, metavar = ('PKG_NAME', 'SALIX_VER'),
      help = 'Update an already existing package PKG_NAME for the Salix SALIX_VER.')
  pkggroup.add_argument('-b', '--build', action = SalixAction, nargs = 5, metavar = ('PKG_NAME', 'PKG_VER', 'SALIX_VER', 'ARCH', 'NUMJOBS'),
      help = """Schedule to build PKG_NAME, version PKG_VER, for Salix version SALIX_VER and ARCH.
NUMJOBS indicate the number of processors/cores to use when building. You cannot define less than 1.
The build is appened to the queue.""")
  pkggroup.add_argument('-q', '--queue', action = SalixQueueAction, nargs = '+', metavar = ('ACTION', 'ARGS'),
      help = """Manage the build queue.
- list : List the queue
- clear : Clear the queue
- remove POSITION[,POSITION ...] : Remove a scheduled build item from the queue.
  POSITION could be a position or a range in the form 2-5.
- run : Execute the builds item in order the queue. Each successful build is removed from the queue.""")
  pkggroup.add_argument('-i', '--interactive', action = 'store_true',
      help = 'Will enter an interactive mode if used with -l, -p, -v, -q.')
  submitgroup = parser.add_argument_group('Submitting options')
  submitgroup.add_argument('-d', '--dedup', action = SalixAction, nargs = 0,
      help = 'De duplicate files using hardlinks for each package.')
  submitgroup.add_argument('-r', '--rsync', action = SalixAction, nargs = 0,
      help = 'Rsync the local repo to your remote one.')
  submitgroup.add_argument('-t', '--ticket', action = SalixAction, nargs = 3, metavar = ('PKG_NAME', 'SALIX_VER', 'TICKET_NUMBER'),
      help = """Create a ticket on Salix Tracker about PKG_NAME and Salix SALIX_VER for all latest built arch.
If TICKET_NUMBER is not 'new', add it as a comment on that ticket rather than creating a new one.""")
  args = parser.parse_args()
  if not args.action:
    parser.print_usage()
    parser.exit(1)
  spkging = SalixPackaging()
  spkging.args = vars(args)
  try:
    getattr(spkging, 'action_' + args.action)()
  except ActionInterruptedException as e:
    print(e)
    sys.exit(2)
  sys.exit(0)
